"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports["default"] = syncFirebase;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _firebase = require("firebase");

var _firebase2 = _interopRequireDefault(_firebase);

var _lodashIsEqual = require("lodash/isEqual");

var _lodashIsEqual2 = _interopRequireDefault(_lodashIsEqual);

var _lodashDifference = require("lodash/difference");

var _lodashDifference2 = _interopRequireDefault(_lodashDifference);

var _lodashIntersection = require("lodash/intersection");

var _lodashIntersection2 = _interopRequireDefault(_lodashIntersection);

var _actionsFirebase = require("./actions/firebase");

var _syncFirebaseCreateOptions = require("./syncFirebase/createOptions");

var _syncFirebaseCreateOptions2 = _interopRequireDefault(_syncFirebaseCreateOptions);

var _syncFirebaseSubscribe = require("./syncFirebase/subscribe");

var _syncFirebaseSubscribe2 = _interopRequireDefault(_syncFirebaseSubscribe);

var _syncFirebaseUnsubscribe = require("./syncFirebase/unsubscribe");

var _syncFirebaseUnsubscribe2 = _interopRequireDefault(_syncFirebaseUnsubscribe);

var _syncFirebaseUnsubscribeAll = require("./syncFirebase/unsubscribeAll");

var _syncFirebaseUnsubscribeAll2 = _interopRequireDefault(_syncFirebaseUnsubscribeAll);

function syncFirebase() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var apiKey = options.apiKey;
  var store = options.store;
  var projectId = options.projectId;
  var databaseURL = options.databaseURL;
  var _options$name = options.name;
  var name = _options$name === undefined ? "[DEFAULT]" : _options$name;
  var _options$bindings = options.bindings;
  var bindings = _options$bindings === undefined ? {} : _options$bindings;
  var _options$onCancel = options.onCancel;
  var onCancel = _options$onCancel === undefined ? function () {} : _options$onCancel;
  var onAuth = options.onAuth;
  var pathParams = options.pathParams;

  if (typeof store === "undefined") {
    throw new Error("syncFirebase: Redux store reference not found in options");
  }

  if (typeof projectId === "undefined") {
    throw new Error("syncFirebase: projectId not found in options");
  }

  if (typeof apiKey === "undefined") {
    throw new Error("syncFirebase: apiKey not found in options");
  }

  if (typeof url !== "undefined") {
    throw new Error("syncFirebase: url is deprecated in options, use projectId & apiKey instead");
  }

  var config = {
    apiKey: apiKey,
    authDomain: projectId + ".firebaseapp.com",
    databaseURL: databaseURL ? databaseURL : "https://" + projectId + ".firebaseio.com",
    storageBucket: projectId + ".appspot.com"
  };

  store.dispatch((0, _actionsFirebase.updateConfig)({ name: name }));

  var app = _firebase2["default"].initializeApp(config, name);
  var rootRef = _firebase2["default"].database(app).ref();

  var state = {
    appName: name,
    projectId: projectId,
    store: store,
    pathParams: pathParams,
    firebaseRefs: {},
    firebaseListeners: {},
    firebasePopulated: {},
    bindings: bindings
  };

  var currentOptions = (0, _syncFirebaseCreateOptions2["default"])(state);

  function updateSubscriptions() {
    var previousOptions = _extends({}, currentOptions);
    var nextOptions = (0, _syncFirebaseCreateOptions2["default"])(state);

    if (!(0, _lodashIsEqual2["default"])(currentOptions, nextOptions)) {
      var nextOptionsKeys = Object.keys(nextOptions);
      var currentOptionsKeys = Object.keys(currentOptions);

      var subscribed = (0, _lodashDifference2["default"])(nextOptionsKeys, currentOptionsKeys);
      var unsubscribed = (0, _lodashDifference2["default"])(currentOptionsKeys, nextOptionsKeys);
      var remaining = (0, _lodashIntersection2["default"])(currentOptionsKeys, nextOptionsKeys);

      // update currentOptions as we're done with comparisons
      currentOptions = nextOptions;

      // unsubscribe removed bindings
      unsubscribed.forEach((0, _syncFirebaseUnsubscribe2["default"])(state));

      // subscribe new bindings
      subscribed.forEach((0, _syncFirebaseSubscribe2["default"])(state, currentOptions, onCancel));

      // check if subscription paths or queries have changed
      remaining.forEach(function (localBinding) {
        if (!(0, _lodashIsEqual2["default"])(currentOptions[localBinding].path, previousOptions[localBinding].path) || !(0, _lodashIsEqual2["default"])(currentOptions[localBinding].queryState, previousOptions[localBinding].queryState)) {
          (0, _syncFirebaseUnsubscribe2["default"])(state)(localBinding);

          // resubscribe with new path / query
          (0, _syncFirebaseSubscribe2["default"])(state, currentOptions, onCancel)(localBinding);
        }
      });
    }
  }

  store.subscribe(updateSubscriptions);

  _firebase2["default"].database(app).ref(".info/connected").on("value", function (snapshot) {
    if (snapshot.val() === true) {
      store.dispatch((0, _actionsFirebase.connect)());
    }
  }, _actionsFirebase.revokePermissions);

  // we need to check for existence of onAuthStateChanged as node version doesn't include it
  if (_firebase2["default"].auth(app) && typeof _firebase2["default"].auth(app).onAuthStateChanged === "function") {
    _firebase2["default"].auth(app).onAuthStateChanged(function (authData) {
      // TODO: decide proper user data format
      // current format is like this for backwards compatibility with 1.x
      var user = authData ? _extends({}, authData.providerData[0], { uid: authData.uid }) : null;
      if (user) {
        store.dispatch((0, _actionsFirebase.authenticateUser)(user));
      } else {
        store.dispatch((0, _actionsFirebase.unauthenticateUser)());
      }
      if (onAuth && typeof onAuth === "function") {
        onAuth(user, rootRef);
      }
    });
  }

  // initial subscriptions
  Object.keys(currentOptions).forEach((0, _syncFirebaseSubscribe2["default"])(state, currentOptions, onCancel));

  // resolve initialized promise when firebase connection has been established
  // and initial fetch has been marked as done
  var initialized = new Promise(function (resolve) {
    var unsub = store.subscribe(function () {
      var _store$getState = store.getState();

      var firebase = _store$getState.firebase;

      if (firebase.connected && firebase.initialFetchDone) {
        resolve();
        unsub();
      }
    });
  });

  // immediately mark initial fetch completed if we aren't initially subscribed to any stores
  if (!Object.keys(currentOptions).length) {
    store.dispatch((0, _actionsFirebase.completeInitialFetch)());
  }

  // mark initial values received for stores that don't have initial value
  (0, _lodashDifference2["default"])(Object.keys(bindings), Object.keys(currentOptions)).forEach(function (localBinding) {
    store.dispatch((0, _actionsFirebase.receiveInitialValue)(localBinding));
  });

  return Object.defineProperties({
    unsubscribe: function unsubscribe() {
      return (0, _syncFirebaseUnsubscribeAll2["default"])(state);
    },
    addBinding: function addBinding(binding) {
      var name = binding.name;

      var rest = _objectWithoutProperties(binding, ["name"]);

      if (name) {
        bindings[name] = rest;
        // run subscription checks manually as we've added new binding
        updateSubscriptions();
      }
    },
    removeBinding: function removeBinding(name) {
      if (bindings[name]) {
        delete bindings[name];
        // run subscription checks manually as we've deleted binding
        updateSubscriptions();
      }
    },
    updateBinding: function updateBinding(binding) {
      var name = binding.name;

      var updatedProps = _objectWithoutProperties(binding, ["name"]);

      if (bindings[name]) {
        bindings[name] = _extends({}, bindings[name], updatedProps);
        // run subscription checks manually as we've updated binding
        updateSubscriptions();
      }
    }
  }, {
    refs: {
      enumerable: false,
      writable: false,
      value: state.firebaseRefs
    },
    listeners: {
      enumerable: false,
      writable: false,
      value: state.firebaseListeners
    },
    populated: {
      enumerable: false,
      writable: false,
      value: state.firebasePopulated
    },
    initialized: {
      enumerable: false,
      writable: false,
      value: initialized
    }
  });
}

module.exports = exports["default"];